/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "interface.h"
#include <stdio.h>
#include <stdlib.h>
#include <rpc/pmap_clnt.h>
#include <string.h>
#include <memory.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include "queue.h"

#ifndef SIG_PF
#define SIG_PF void(*)(int)
#endif

#define MAX_ID_LEN 15
#define LINE_SIZE 100

int users_size;
char **users;

int res_size;
char **resources;

StringQueue *q;

int token_life;

struct user *users_list;

void initializeQueue(StringQueue *queue) {
    queue->front = queue->rear = NULL;
}

int isEmpty(StringQueue *queue) {
    return queue->front == NULL;
}

void enqueue(StringQueue *queue, char *str) {
    
    Node *newNode = (Node *)malloc(sizeof(Node));
    if (newNode == NULL) {
        perror("Error allocating memory");
        exit(EXIT_FAILURE);
    }
    
    if (str[strlen(str) - 1] == '\n') {
		newNode->data = strndup(str, strlen(str) - 1);
	} else {
		newNode->data = strdup(str);
	}
	
    if (newNode->data == NULL) {
        perror("Error allocating memory");
        free(newNode);
        exit(EXIT_FAILURE);
    }

    newNode->next = NULL;

    if (isEmpty(queue)) {
        queue->front = queue->rear = newNode;
    } else {
        queue->rear->next = newNode;
        queue->rear = newNode;
    }
}

char* dequeue(StringQueue *queue) {
    if (isEmpty(queue)) {
        fprintf(stderr, "Error: Queue is empty\n");
        exit(EXIT_FAILURE);
    }

    char *data = queue->front->data;

    Node *temp = queue->front;
    queue->front = queue->front->next;

    if (queue->front == NULL) {
        queue->rear = NULL;
    }

    free(temp);

    return data;
}

void freeQueue(StringQueue *queue) {
    while (!isEmpty(queue)) {
        char *data = dequeue(queue);
        free(data);
    }
}

void printQueue(StringQueue *queue) {
    Node *current = queue->front;
    while (current != NULL) {
        printf("%s\n", current->data);
        current = current->next;
    }
}

/*
	Functie care se ocupa cu cititul permisiunilor din fisier
 */
void read_approvals(char *file_path, StringQueue *q) {
	FILE* perm_fp = fopen(file_path, "r");
	if (perm_fp == NULL) {
		fprintf(stderr, "%s\n", "error opening approvals file");
	}
	char line[LINE_SIZE];
	memset(line, 0, LINE_SIZE);
	while(fgets(line, sizeof(line), perm_fp) != NULL) {
		enqueue(q, line);
		memset(line, 0, LINE_SIZE);
	}
}

/*
	Functie care se ocupa cu cititul userilor din fisier
 */
void read_users_from_dba(char *file_path) {
	FILE* users_fp = fopen(file_path, "r");
	if (users_fp == NULL) {
		fprintf(stderr, "%s\n", "error opening users file");
		exit(1);
	}

	fscanf(users_fp, "%d", &users_size);
	users = (char **)malloc(users_size * sizeof(char *));
	for (int i = 0; i < users_size; i++) {
		users[i] = (char *)malloc(MAX_ID_LEN * sizeof(char));
		fscanf(users_fp, "%s", users[i]);
	}
}

/*
	Functie care se ocupa cu cititul resurselor din fisier
 */
void read_resources_from_dba(char *file_path) {
	FILE* res_fp = fopen(file_path, "r");	
	if(res_fp == NULL) {
		fprintf(stderr, "%s\n", "error opening resources file");
		exit(1);
	}

	fscanf(res_fp, "%d", &res_size);
	resources = (char **)malloc(res_size * sizeof(char *));
	for (int i = 0; i < res_size; i++) {
		resources[i] = (char *)malloc(MAX_ID_LEN * sizeof(char));
		fscanf(res_fp, "%s", resources[i]);
	}
}

static char **
_request_authorization_1 (char * *argp, struct svc_req *rqstp)
{
	return (request_authorization_1_svc(*argp, rqstp));
}

static char **
_approve_request_1 (char * *argp, struct svc_req *rqstp)
{
	return (approve_request_1_svc(*argp, rqstp));
}

static struct token_pair *
_request_access_token_1 (request_access_token_1_argument *argp, struct svc_req *rqstp)
{
	return (request_access_token_1_svc(argp->arg1, argp->arg2, argp->arg3, argp->arg4, rqstp));
}

static struct status *
_validate_delegated_action_1 (validate_delegated_action_1_argument *argp, struct svc_req *rqstp)
{
	return (validate_delegated_action_1_svc(argp->arg1, argp->arg2, argp->arg3, rqstp));
}

static void
interface_prog_1(struct svc_req *rqstp, register SVCXPRT *transp)
{
	union {
		char *request_authorization_1_arg;
		char *approve_request_1_arg;
		request_access_token_1_argument request_access_token_1_arg;
		validate_delegated_action_1_argument validate_delegated_action_1_arg;
	} argument;
	char *result;
	xdrproc_t _xdr_argument, _xdr_result;
	char *(*local)(char *, struct svc_req *);

	switch (rqstp->rq_proc) {
	case NULLPROC:
		(void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
		return;

	case REQUEST_AUTHORIZATION:
		_xdr_argument = (xdrproc_t) xdr_wrapstring;
		_xdr_result = (xdrproc_t) xdr_wrapstring;
		local = (char *(*)(char *, struct svc_req *)) _request_authorization_1;
		break;

	case APPROVE_REQUEST:
		_xdr_argument = (xdrproc_t) xdr_wrapstring;
		_xdr_result = (xdrproc_t) xdr_wrapstring;
		local = (char *(*)(char *, struct svc_req *)) _approve_request_1;
		break;

	case REQUEST_ACCESS_TOKEN:
		_xdr_argument = (xdrproc_t) xdr_request_access_token_1_argument;
		_xdr_result = (xdrproc_t) xdr_token_pair;
		local = (char *(*)(char *, struct svc_req *)) _request_access_token_1;
		break;

	case VALIDATE_DELEGATED_ACTION:
		_xdr_argument = (xdrproc_t) xdr_validate_delegated_action_1_argument;
		_xdr_result = (xdrproc_t) xdr_status;
		local = (char *(*)(char *, struct svc_req *)) _validate_delegated_action_1;
		break;

	default:
		svcerr_noproc (transp);
		return;
	}
	memset ((char *)&argument, 0, sizeof (argument));
	if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		svcerr_decode (transp);
		return;
	}
	result = (*local)((char *)&argument, rqstp);
	if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
		svcerr_systemerr (transp);
	}
	if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
		fprintf (stderr, "%s", "unable to free arguments");
		exit (1);
	}
	return;
}

int
main (int argc, char **argv)
{
	register SVCXPRT *transp;

	pmap_unset (INTERFACE_PROG, INTERFACE_VERS);

	transp = svcudp_create(RPC_ANYSOCK);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create udp service.");
		exit(1);
	}
	if (!svc_register(transp, INTERFACE_PROG, INTERFACE_VERS, interface_prog_1, IPPROTO_UDP)) {
		fprintf (stderr, "%s", "unable to register (INTERFACE_PROG, INTERFACE_VERS, udp).");
		exit(1);
	}

	transp = svctcp_create(RPC_ANYSOCK, 0, 0);
	if (transp == NULL) {
		fprintf (stderr, "%s", "cannot create tcp service.");
		exit(1);
	}
	if (!svc_register(transp, INTERFACE_PROG, INTERFACE_VERS, interface_prog_1, IPPROTO_TCP)) {
		fprintf (stderr, "%s", "unable to register (INTERFACE_PROG, INTERFACE_VERS, tcp).");
		exit(1);
	}

	setbuf(stdout, NULL);

    // Citim userii din baza de date
    read_users_from_dba(argv[1]);

    // Citim resursele din baza de date
    read_resources_from_dba(argv[2]);

    q = (StringQueue *)malloc(sizeof(StringQueue));
    initializeQueue(q);

    // Citim permisiunile si le adaugam intr-o coada
    read_approvals(argv[3], q);

    if (argc > 4) {
        token_life = atoi(argv[4]);
    } else {
        token_life = 0;
    }
    
    // Initializam baza de date
    users_list = (struct user *)malloc(users_size * sizeof(struct user));
    for (int i = 0; i < users_size; i++) {
        users_list[i].username = strdup(users[i]);
        users_list[i].req_auth_token = NULL;
        users_list[i].resources_token = NULL;
        users_list[i].reg_token = NULL;
        users_list[i].val_time = 0;
        users_list[i].automatic_refresh = 0;
        users_list[i].res = (struct resource *)malloc(res_size * sizeof(struct resource));
        for (int j = 0; j < res_size; j++) {
            users_list[i].res[j].res_type = strdup(resources[j]);
            users_list[i].res[j].perms = NULL;
        }
    }

	svc_run ();
	fprintf (stderr, "%s", "svc_run returned");
	exit (1);
	/* NOTREACHED */
}
